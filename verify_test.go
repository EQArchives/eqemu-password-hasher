package main

import (
	"fmt"
	"testing"

	"golang.org/x/crypto/scrypt"
)

func testHashVector(t *testing.T, label, password, fullHash string) {
	t.Helper()
	fmt.Printf("=== %s ===\n", label)
	fmt.Printf("Password: %s\n", password)
	fmt.Printf("Full hash: %s\n", fullHash)

	// Parse: $7$ (3) + C (1) + 6.... (5) + /.... (5) = 14 chars prefix
	prefix := fullHash[:14]
	rest := fullHash[14:]
	dollarIdx := -1
	for i, c := range rest {
		if c == '$' {
			dollarIdx = i
			break
		}
	}
	if dollarIdx < 0 {
		t.Fatalf("No $ separator found in hash portion")
	}
	encodedSalt := rest[:dollarIdx]
	expectedDK := rest[dollarIdx+1:]

	fmt.Printf("Prefix: %s\n", prefix)
	fmt.Printf("Encoded salt (%d chars): %s\n", len(encodedSalt), encodedSalt)
	fmt.Printf("Expected DK  (%d chars): %s\n", len(expectedDK), expectedDK)

	N := 16384
	r := 8
	p := 1
	keyLen := 32

	dk, err := scrypt.Key([]byte(password), []byte(encodedSalt), N, r, p, keyLen)
	if err != nil {
		t.Fatal(err)
	}
	gotDK := encode64Bytes(dk)
	fmt.Printf("Computed DK  (%d chars): %s\n", len(gotDK), gotDK)
	fmt.Printf("Match: %v\n\n", gotDK == expectedDK)

	if gotDK != expectedDK {
		t.Errorf("%s: hash mismatch", label)
	}
}

// verifySCrypt replicates libsodium's crypto_pwhash_scryptsalsa208sha256_str_verify
func verifySCrypt(storedHash, password string) bool {
	if len(storedHash) < 14 || storedHash[:3] != "$7$" {
		return false
	}

	// Find the salt/hash separator (last $)
	lastDollar := -1
	for i := len(storedHash) - 1; i >= 0; i-- {
		if storedHash[i] == '$' {
			lastDollar = i
			break
		}
	}
	if lastDollar <= 3 {
		return false
	}

	// Extract encoded salt (after the 14-char prefix, before the last $)
	encodedSalt := storedHash[14:lastDollar]
	expectedDK := storedHash[lastDollar+1:]

	// Recompute with same params
	dk, err := scrypt.Key([]byte(password), []byte(encodedSalt), 16384, 8, 1, 32)
	if err != nil {
		return false
	}

	return encode64Bytes(dk) == expectedDK
}

func TestSCryptVector(t *testing.T) {
	password := "Yawgmoth69!!??"

	// Hash known to work on the server
	testHashVector(t, "Server-generated (known working)",
		password,
		"$7$C6..../....o6qKd2HVUARWTdHViztsqQ.eGYS8Vi7jwD6jijrJtrC$CAyWIxCQRHRgYzqyj/6mG9u6kuyQURTT7R9hoeNrg90")

	// Hash generated by our app (reported as not working)
	testHashVector(t, "App-generated (reported broken)",
		password,
		"$7$C6..../....on6C5csxdh5qCyNitycuPn1i6R/sGmYN0oZ86Io3yy/$8I/Hr.E.m785FbRYIYP4VQrN9tEdSNZvSqLrUahOuk1")
}

func TestSCryptVerify(t *testing.T) {
	password := "Yawgmoth69!!??"

	serverHash := "$7$C6..../....o6qKd2HVUARWTdHViztsqQ.eGYS8Vi7jwD6jijrJtrC$CAyWIxCQRHRgYzqyj/6mG9u6kuyQURTT7R9hoeNrg90"
	appHash := "$7$C6..../....on6C5csxdh5qCyNitycuPn1i6R/sGmYN0oZ86Io3yy/$8I/Hr.E.m785FbRYIYP4VQrN9tEdSNZvSqLrUahOuk1"

	fmt.Printf("Verify server hash: %v\n", verifySCrypt(serverHash, password))
	fmt.Printf("Verify app hash:    %v\n", verifySCrypt(appHash, password))
	fmt.Printf("Verify wrong pass:  %v\n", verifySCrypt(appHash, "wrongpassword"))

	// Generate a new hash with our app and immediately verify it
	newHash, err := hashSCrypt(password)
	if err != nil {
		t.Fatal(err)
	}
	fmt.Printf("\nNewly generated hash: %s\n", newHash)
	fmt.Printf("Verify new hash:      %v\n", verifySCrypt(newHash, password))
	fmt.Printf("Hash length:          %d\n", len(newHash))

	if !verifySCrypt(serverHash, password) {
		t.Error("Server hash failed verification")
	}
	if !verifySCrypt(appHash, password) {
		t.Error("App hash failed verification")
	}
	if !verifySCrypt(newHash, password) {
		t.Error("Newly generated hash failed verification")
	}
	if verifySCrypt(newHash, "wrongpassword") {
		t.Error("Wrong password should not verify")
	}
}

// decode64Bytes decodes custom base64 back to raw bytes
func decode64Bytes(src string) []byte {
	var atoi64 [256]int
	for i := range atoi64 {
		atoi64[i] = -1
	}
	for i, c := range itoa64 {
		atoi64[c] = i
	}

	var result []byte
	i := 0
	for i < len(src) {
		var value uint32
		var bits int
		for bits < 24 && i < len(src) {
			c := atoi64[src[i]]
			if c < 0 {
				break
			}
			value |= uint32(c) << bits
			bits += 6
			i++
		}
		for b := 0; b < bits/8; b++ {
			result = append(result, byte(value&0xff))
			value >>= 8
		}
	}
	return result
}
